// Generated by CoffeeScript 1.10.0

/*
HTTP class 

This class is extended by the other API classes. Contains basic implementations of get, post, put and delete plus some utility functions.

@author Torstein Thune
@copyright Microbrew.it 2015
 */

(function() {
  var Http, querystring, request;

  request = require('request');

  querystring = require('querystring');

  Http = (function() {
    function Http() {}

    Http.prototype.endpoint = '';

    Http.prototype._generateUrl = function(partial) {
      var url;
      if (partial == null) {
        partial = '';
      }
      url = "" + this.apiUrl;
      if (this.endpoint && this.endpoint !== '') {
        url += "/" + this.endpoint;
      }
      if (partial && partial !== '') {
        url += "/" + partial;
      }
      return url;
    };

    Http.prototype._parseParams = function(params) {
      var key, paramTuples, val;
      paramTuples = [];
      for (key in params) {
        val = params[key];
        paramTuples.push(key + "=" + val);
      }
      return paramTuples.join('&');
    };

    Http.prototype._handleResponse = function(error, response, body, token, callback) {
      var e, error1;
      if (error) {
        return callback(error, null, null, token);
      } else {
        try {
          body = JSON.parse(body);
          if (body.error) {
            callback(body.error, null, null, token);
            return;
          }
        } catch (error1) {
          e = error1;
        }
        return callback(error, response, body, token);
      }
    };

    Http.prototype.authenticate = function(username, password, callback) {
      var body, postObj;
      if (!(this.clientSecret && this.clientId)) {
        throw new Error('You cannot authenticate without clientSecret and clientId.');
      }
      body = {
        username: username,
        password: password,
        grant_type: 'password',
        client_id: this.clientId,
        client_secret: this.clientSecret,
        scope: 'openid profile roles microbrewit-api offline_access'
      };
      postObj = {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: querystring.stringify(body),
        url: this.authUrl + "/connect/token"
      };
      return this.post(postObj, callback);
    };

    Http.prototype.refreshToken = function(token, callback) {
      var body, postObj;
      if (!token) {
        return callback(null, null, null);
      } else {
        if (new Date().getTime() > new Date(token['.expires']).getTime() - 30000) {
          body = {
            refresh_token: token.refresh_token,
            grant_type: 'refresh_token',
            client_id: this.clientId,
            client_secret: this.clientSecret,
            scope: 'openid profile roles microbrewit-api offline_access'
          };
          postObj = {
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: querystring.stringify(body),
            url: this.authUrl + "/connect/token"
          };
          return this.post(postObj, callback);
        } else {
          return callback(null, null, token);
        }
      }
    };

    Http.prototype.post = function(query, callback, token) {
      if (token == null) {
        token = false;
      }
      return this.refreshToken(token, (function(_this) {
        return function(err, response, token) {
          var base;
          if (!query.headers) {
            query.headers = {};
          }
          if ((base = query.headers)['Content-Type'] == null) {
            base['Content-Type'] = 'application/json';
          }
          if (token != null ? token.access_token : void 0) {
            query.headers['Authorization'] = "Bearer " + token.access_token;
          }
          if (!query.url) {
            if (query.partial == null) {
              query.partial = '';
            }
            if (query.params == null) {
              query.params = {};
            }
            if (query.url == null) {
              query.url = (_this._generateUrl(query.partial)) + "?" + (_this._parseParams(query.params));
            }
            delete query.partial;
            delete query.params;
          }
          return request.post(query, function(error, response, body) {
            return _this._handleResponse(error, response, body, token, callback);
          });
        };
      })(this));
    };

    Http.prototype.get = function(query, callback, token) {
      if (token == null) {
        token = false;
      }
      return this.refreshToken(token, (function(_this) {
        return function(err, response, token) {
          var base;
          if (query.body && typeof query.body === 'object') {
            query.body = JSON.stringify(query.body);
          }
          if (query.headers == null) {
            query.headers = {};
          }
          if ((base = query.headers)['Content-Type'] == null) {
            base['Content-Type'] = 'application/json';
          }
          if (token != null ? token.access_token : void 0) {
            query.headers['Authorization'] = "Bearer " + token.access_token;
          }
          if (!query.url) {
            if (query.partial == null) {
              query.partial = '';
            }
            if (query.params == null) {
              query.params = {};
            }
            if (query.url == null) {
              query.url = (_this._generateUrl(query.partial)) + "?" + (_this._parseParams(query.params));
            }
            delete query.partial;
            delete query.params;
          }
          return request.get(query, function(error, response, body) {
            return _this._handleResponse(error, response, body, token, callback);
          });
        };
      })(this));
    };

    Http.prototype.put = function(query, callback, token) {
      if (token == null) {
        token = false;
      }
      if (!token) {
        return callback('Authentication required for PUT');
      }
      return this.refreshToken(token, (function(_this) {
        return function(err, response, token) {
          var base;
          if (query.body && typeof query.body === 'object') {
            query.body = JSON.stringify(query.body);
          }
          if (query.headers == null) {
            query.headers = {};
          }
          if ((base = query.headers)['Content-Type'] == null) {
            base['Content-Type'] = 'application/json';
          }
          if (token != null ? token.access_token : void 0) {
            query.headers['Authorization'] = "Bearer " + token.access_token;
          }
          if (!query.url) {
            if (query.partial == null) {
              query.partial = '';
            }
            if (query.params == null) {
              query.params = {};
            }
            if (query.url == null) {
              query.url = (_this._generateUrl(query.partial)) + "?" + (_this._parseParams(query.params));
            }
            delete query.partial;
            delete query.params;
          }
          return request.put(query, function(error, response, body) {
            return _this._handleResponse(error, response, body, token, callback);
          });
        };
      })(this));
    };

    Http.prototype["delete"] = function(query, callback, token) {
      if (token == null) {
        token = false;
      }
      if (!token) {
        return callback('Authentication required for DELETE');
      }
      return this.refreshToken(token, (function(_this) {
        return function(err, response, token) {
          if (token != null ? token.access_token : void 0) {
            if (query.headers == null) {
              query.headers = {};
            }
            query.headers['Authorization'] = "Bearer " + token.access_token;
          }
          if (!query.url) {
            if (query.partial == null) {
              query.partial = '';
            }
            if (query.params == null) {
              query.params = {};
            }
            if (query.url == null) {
              query.url = (_this._generateUrl(query.partial)) + "?" + (_this._parseParams(query.params));
            }
            delete query.partial;
            delete query.params;
          }
          return request.del(query, function(error, response, body) {
            return _this._handleResponse(error, response, body, token, callback);
          });
        };
      })(this));
    };

    return Http;

  })();

  module.exports = Http;

}).call(this);
